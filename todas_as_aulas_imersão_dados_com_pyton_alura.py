# -*- coding: utf-8 -*-
"""Todas as Aulas - Imersão dados com Pyton Alura.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Svp7BMSKWDIbCNrWe6yC_ohba3le9U1n

# Aula 1 - Análise de Dados com Pandas
"""

import pandas as pd

df = pd.read_csv("https://raw.githubusercontent.com/guilhermeonrails/data-jobs/refs/heads/main/salaries.csv")

df.head()

df.info()

df.describe()

df.shape

linhas,colunas = df.shape[0] ,df.shape[1]
print('N° de Linhas:',linhas)
print('N° de Colunas:',colunas)

#Auto explicativo, nos mostra as colunas presentes no arquivo
df.columns

#usamos o gemni para renomear as colunas para português brasileiro
df.rename(columns={
    'work_year': 'ano',
    'experience_level': 'senoridade',
    'employment_type': 'contrato',
    'job_title': 'cargo',
    'salary': 'salario',
    'salary_currency': 'moeda',
    'salary_in_usd': 'usd',
    'employee_residence': 'residencia',
    'remote_ratio': 'remoto',
    'company_location': 'empresa',
    'company_size': 'tamanho_empresa'
}, inplace=True)

df.columns

df["senoridade"].value_counts()

df["contrato"].value_counts()

df["remoto"].value_counts()

df["tamanho_empresa"].value_counts()

df["empresa"].value_counts()

senoridade = {
    'SE': 'Sênior',
    'MI': 'Pleno',
    'EN': 'Júnior',
    'EX': 'Executivo'
}

df['senoridade'] = df['senoridade'].replace(senoridade)
df['senoridade'].value_counts()

df['contrato'].value_counts()

contrato = {
    'FT' : 'Tempo Integral',
    'CT' : 'Contrato',
    'PT' : 'Meio Periodo',
    'FL' : 'Freelancer'
}
df['contrato'] = df['contrato'].replace(contrato)
df['contrato'].value_counts()

df["tamanho_empresa"].value_counts()

tamanho_empresa = {
    'M' : 'Media',
    'L' : 'Grande',
    'S' : 'Pequena'
}
df['tamanho_empresa'] = df['tamanho_empresa'].replace(tamanho_empresa)
df['tamanho_empresa'].value_counts()

df.columns

df.head()

"""# Aula 2 - Limpeza e Preparação de Dados"""

df.isnull()

df.head()

df.isnull().sum()

#Este método vai nos trazer quais são os valores unicos presentes nesta coluna
df['ano'].unique()

# Começamos com o DataFrame "df".
# Dentro dos colchetes, colocamos um filtro booleano para decidir quais linhas serão exibidas.
# Aqui, usamos df.isnull() para gerar um DataFrame booleano indicando onde há valores NaN (nulos).
# Em seguida, .any(axis=1) verifica, linha por linha (axis=1 = horizontal),
# se existe pelo menos um valor nulo naquela linha, retornando True ou False.
# Por fim, df[...] retorna apenas as linhas que tiveram True no filtro.
df[df.isnull().any(axis=1)]

#Importação de biblioteca para operações com numeros
import numpy as np

#Criação de Data Frame para testes
df_salarios = pd.DataFrame({
  'Nome': ["João", "Maria", "Tamara", "Bento", "Plinio"],
  'Salario' : [4000, np.nan, 5000, np.nan, 100000]
})
#df_salarios é nossa base
#salario_media é a nossa coluna que estamos criando
#vamos preencher os salarios da média de salarios
#round é arredondando para 2 casas decimais
'''calcula a média e substitui os nulos e arredonda'''
df_salarios['salario_media'] = df_salarios['Salario'].fillna(df_salarios['Salario'].mean().round(2))

'''Calcula a mediana e substitui os nulos pela mediana'''
df_salarios['salario_mediana'] = df_salarios['Salario'].fillna(df_salarios['Salario'].median())

df_salarios

df_temperaturas = pd.DataFrame({
    'Dia': ['Segunda', 'Terça', 'Quarta','Quinta','Sexta'],
    'Temperatura': [30,np.nan,np.nan,28,27]
})

#vai completar com o valor anterior
df_temperaturas['Preenchido_Ffill'] = df_temperaturas['Temperatura'].ffill()

#vai completar com o valor sucessor
df_temperaturas['Preenchido_Bfill'] = df_temperaturas['Temperatura'].bfill()
df_temperaturas

df_cidades = pd.DataFrame({
    'Nome': ["João", "Maria", "Tamara", "Bento", "Plinio"],
    'Cidades': ['Ponta Grossa', np.nan, 'Eldorado', 'Registro', np.nan]
})

df_cidades['Cidade_Preenchida'] = df_cidades['Cidades'].fillna('Não Informado')
df_cidades

df_limpo = df.dropna()

df_limpo.isnull().sum()

df_limpo.head()

df_limpo.info()

#Aqui estamos convertendo a varivael do "Ano" de float64 para int64
df_limpo = df_limpo.assign(ano = df_limpo['ano'].astype('int64'))

df_limpo.info()

df_limpo.head()

df_limpo = df_limpo.assign(salario = df_limpo['salario'].astype('float64'))

df_limpo.info()

df_limpo.head()

df_limpo = df_limpo.assign(usd = df_limpo['usd'].astype('float64'))

df_limpo.head()

df_limpo.info()

"""# Aula 3 - Vizualização de Dados"""

df_limpo.head()

#plotando os graficos
df_limpo['senoridade'].value_counts().plot(kind='bar',title='Distribuição de Senoridade')

'''
É uma biblioteca Python para visualização de dados baseada no Matplotlib.
Oferece gráficos mais bonitos e prontos com menos código.
Integra muito bem com Pandas DataFrames.
'''
import seaborn as sns

sns.barplot(data = df_limpo, x = 'senoridade', y = 'usd')

'''
É um conjunto de funções para criar gráficos e visualizações em Python, parecido com a forma como o MATLAB faz.

É a base que muitas bibliotecas (como o Seaborn) usam para exibir gráficos.
'''
import matplotlib.pyplot as plt

#definindo o tamanho da figura
plt.figure(figsize=(8,5))

#plotando o grafico
sns.barplot(data = df_limpo, x = 'senoridade', y ='usd')

#Colocando titulo para o gráfico
plt.title('Salario médio por nivel de senoridade')

#Definindo o nome para o eixo x
plt.xlabel('Senoridade')

#Definindo nome para o eixo y
plt.ylabel('Salario médio anual (USD)')

#mostrando o grafico
plt.show()

#Agrupa por 'senoridade', calcula a média de 'usd' e ordena do maior para o menor
df_limpo.groupby('senoridade')['usd'].mean().sort_values(ascending=False)

#ordena a senoridade pela media de USD
ordem = df_limpo.groupby('senoridade')['usd'].mean().sort_values(ascending=False).index

ordem

plt.figure(figsize=(8,5))
sns.barplot(data = df_limpo, x = 'senoridade', y ='usd',order = ordem) #no final estamos ordenando tudo
plt.title('Salario médio por nivel de senoridade')
plt.xlabel('Senoridade')
plt.ylabel('Salario médio anual (USD)')
plt.show()

plt.figure(figsize=(8,4))
#criando histograma
#bins = 50 (valores indo 50 a 50)
sns.histplot(df_limpo['usd'], bins=50,kde=True)
plt.title('Distribuição Salarial Anual')
plt.xlabel('Salario (USD)')
plt.ylabel('Frequência')
plt.show()

plt.figure(figsize=(9,5))
#criando histograma
#bins = 50 (valores indo 50 a 50)
sns.histplot(df_limpo['usd'], bins=100,kde=True)
plt.title('Distribuição Salarial Anual')
plt.xlabel('Salario (USD)')
plt.ylabel('Frequência')
plt.show()

plt.figure(figsize=(8,5))
sns.boxplot(x=df_limpo['usd'])
plt.title('Boxplot Salarial')
plt.xlabel('Salario (USD)')
plt.show()

ordem_senioridade = ['Júnior','Pleno','Sênior','Executivo']
plt.figure(figsize=(8,5))
sns.boxplot(x = 'senoridade', y='usd',data = df_limpo, order = ordem_senioridade)
plt.title('Distribuição Salarial por Senioridade')
plt.xlabel('Senioridade')
plt.ylabel('Salario (USD)')
plt.show()

ordem_senioridade = ['Júnior','Pleno','Sênior','Executivo']
plt.figure(figsize=(8,5))
sns.boxplot(x = 'senoridade', y='usd',data = df_limpo, order = ordem_senioridade,palette='Set2',hue='senoridade')
plt.title('Distribuição Salarial por Senioridade')
plt.xlabel('Senioridade')
plt.ylabel('Salario (USD)')
plt.show()

import plotly.express as px

#criando graficos interativos de barras
senoridade_media_salarial = df_limpo.groupby('senoridade')['usd'].mean().sort_values(ascending=False).reset_index()

fig = px.bar(senoridade_media_salarial, x='senoridade', y='usd', title='Média Salarial por Senioridade',
             labels={'senoridade:': 'Nivel Senoridade','usd':'Media Salarial Anual (USD)'})
fig.show()

#fazendo grafico de pizza
remoto_contagem = df_limpo['remoto'].value_counts().reset_index()
remoto_contagem.columns = ['tipo_trabalho','quantidade']
fig = px.pie(remoto_contagem,
             names = 'tipo_trabalho',
             values = 'quantidade',
             title = 'Proporção dos tipos de trabalho'

             )

fig.show()

df_limpo['remoto'] = df['remoto'].map({
    0: 'presencial',
    50: 'hibrido',
    100: 'remoto'
})

#fazendo uma grafico de rosca
remoto_contagem = df_limpo['remoto'].value_counts().reset_index()
remoto_contagem.columns = ['tipo_trabalho','quantidade']
fig = px.pie(remoto_contagem,
             names = 'tipo_trabalho',
             values = 'quantidade',
             title = 'Proporção dos tipos de trabalho',
             hole = 0.5
             )
fig.update_traces(textinfo = 'percent+label')
fig.show()

#Desafio proposto no final da aula.
#Fazer um grafico de salario distribuido por pais do cargo de data science
df_DataScientist = df_limpo[df_limpo['cargo'] == 'Data Scientist']
salario_por_pais_ds = df_DataScientist.groupby('residencia')['usd'].mean().sort_values(ascending=False).reset_index()

fig = px.bar(salario_por_pais_ds,
             x = 'residencia',
             y = 'usd',
             title = 'Distribuição de Salário por País para Data Scientists',
             labels = {'residencia': 'País','usd':'Media Salarial Anual(USD)'},
             color = 'residencia',
             barmode = 'stack')
# Formatando os dados e colocando rótulos
fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')

# Rotacionando o x em -45
fig.update_layout(xaxis_tickangle=-45)

# Definindo a cor de fundo do gráfico
fig.update_layout(plot_bgcolor='lightgray', paper_bgcolor='white')
fig.show()

#Desafio proposto no final da aula.
#Fazer um grafico de salario distribuido por pais do cargo de data science
#Aqui estou usando um gráfico de dispersão
df_DataScientist = df_limpo[df_limpo['cargo'] == 'Data Scientist']
salario_por_pais_ds = df_DataScientist.groupby('residencia')['usd'].mean().sort_values(ascending=False).reset_index()

fig = px.scatter(salario_por_pais_ds,
             x = 'residencia',
             y = 'usd',
             title = 'Distribuição de Salário por País para Data Scientists',
             labels = {'residencia': 'País','usd':'Media Salarial Anual(USD)'},
             color = 'residencia')
fig.show()